#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Wed Mar 26 17:24:23 2025
@author: chiaramarzi
"""

# Import required libraries
from datetime import datetime
import matplotlib as mpl
mpl.rcParams['axes.spines.right'] = False
mpl.rcParams['axes.spines.top'] = False
import matplotlib.pyplot as plt
plt.rc('font', size=6)
import numpy as np
import os
import pandas as pd
from utils import make_confusion_matrix  # Custom function to plot confusion matrices
from sklearn.metrics import auc

# Create a folder to save output images, named with current timestamp
now = datetime.now()
formatted_date_hours = now.strftime("%Y-%m-%d_%H-%M-%S")
directory_path = 'images_' + formatted_date_hours
os.makedirs(directory_path, exist_ok=True)

# Path to results directory generated by the main classification script
results_path = "results_2025-03-26_17-38-09"  # Update this to match your folder name created by the script binary_classification.py

# Load saved confusion matrices (shape: [2, 2, M])
CM = np.load(results_path + '/Group0-Group1-Confusion_matrices.npy')

# Compute average and 95% bootstrap interval (percentile) values
ave_cm = np.mean(CM, axis=2)
perc25_cm = np.percentile(CM, 2.5, axis=2)
perc975_cm = np.percentile(CM, 97.5, axis=2)

# Create cell labels with average and 95% BI for each cell of the confusion matrix
labels = [
    f"{ave_cm[0,0]:.2f}\n[{perc25_cm[0,0]:.2f}, {perc975_cm[0,0]:.2f}]",
    f"{ave_cm[0,1]:.2f}\n[{perc25_cm[0,1]:.2f}, {perc975_cm[0,1]:.2f}]",
    f"{ave_cm[1,0]:.2f}\n[{perc25_cm[1,0]:.2f}, {perc975_cm[1,0]:.2f}]",
    f"{ave_cm[1,1]:.2f}\n[{perc25_cm[1,1]:.2f}, {perc975_cm[1,1]:.2f}]"
]

# Plot and save the average confusion matrix
make_confusion_matrix(
    ave_cm,
    group_names=labels,
    categories=['Group0', 'Group1'],
    cmap='Blues',
    count=False,
    percent=False,
    sum_stats=False,
    vmin=0,
    vmax=1,
    cbar=True
)
plt.savefig(directory_path + '/Group0-Group1-CM_scaled.png', dpi=600, format='png')
plt.close('all')

# ----------------------------
# ROC Curve: median and spread
# ----------------------------

# Load interpolated ROC coordinates from CSV
data = pd.read_csv(results_path + '/Group0-Group1_ROC_coords_test.csv')

# Extract median and IQR (25th and 75th percentile) TPR curves
median_fpr = data['x']
median_tpr = data.iloc[:, 2:].median(axis=1)
q1_tpr = data.iloc[:, 2:].quantile(0.25, axis=1)
q3_tpr = data.iloc[:, 2:].quantile(0.75, axis=1)

# Compute Youden's index and its max
youd_idx = median_tpr - median_fpr
yx = np.argmax(youd_idx)
print(median_fpr[yx], median_tpr[yx])
print('Sensitivity:', median_tpr[yx])
print('Specificity:', 1 - median_fpr[yx])
print('AUC:', auc(median_fpr, median_tpr))

# Plot ROC curve with median and quantile bands
cm = 1 / 2.54  # Convert cm to inches for figure size
plt.figure(figsize=(8.5 * cm, 8.5 * cm))
plt.plot(median_fpr, median_tpr, color='#36ada4', label='Median ROC', alpha=0.8, zorder=2)
plt.plot([0, 1], [0, 1], color='#f77189', label='Random classifier', alpha=0.8)
plt.plot(median_fpr, q1_tpr, linestyle="dotted", linewidth=0.9, color="#a48cf4", label="25th percentile")
plt.plot(median_fpr, q3_tpr, linestyle="dashed", linewidth=0.5, color="#a48cf4", label="75th percentile")
# Optional: mark point of max Youden's index
# plt.scatter(median_fpr[yx], median_tpr[yx], s=10, color="#97a431", label="Max Youden's index", zorder=3)

# Axis and style
plt.xlabel('False Positive Rate')
plt.ylabel('True Positive Rate')
plt.legend()
plt.xlim([-0.05, 1.05])
plt.ylim([-0.05, 1.05])
plt.axis('square')

# Save ROC curve figure
plt.savefig(directory_path + "/Group0-Group1_ROC_AUC_median_roc.png", dpi=600, format="png")
